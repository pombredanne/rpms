# $Id$
# Authority: shuff
# Upstream: Alex Balhatchet <kaoru$slackwise,net>

%define perl_vendorlib %(eval "`perl -V:installvendorlib`"; echo $installvendorlib)
%define perl_vendorarch %(eval "`perl -V:installvendorarch`"; echo $installvendorarch)

%define real_name HTTP-Async

%define perl_prefix %{buildroot}%{_prefix}

Summary: Multiple HTTP request in parallel without locking
Name: perl-HTTP-Async
Version:  0.23
Release: 1%{?dist}
License: Artistic/GPL
Group: Applications/CPAN
URL: http://search.cpan.org/dist/HTTP-Async/

Source: http://search.cpan.org/CPAN/authors/id/K/KA/KAORU/HTTP-Async-%{version}.tar.gz
BuildRoot: %{_tmppath}/%{name}-%{version}-%{release}-root
BuildArch: noarch

BuildRequires: perl
BuildRequires: perl(Carp)
BuildRequires: perl(Data::Dumper)
BuildRequires: perl(ExtUtils::MakeMaker)
BuildRequires: perl(HTTP::Request)
BuildRequires: perl(HTTP::Response)
BuildRequires: perl(HTTP::Server::Simple::CGI)
BuildRequires: perl(HTTP::Status)
BuildRequires: perl(IO::Select)
BuildRequires: perl(LWP::UserAgent)
BuildRequires: perl(Net::HTTP)
BuildRequires: perl(Net::HTTP::NB)
BuildRequires: perl(Net::HTTPS::NB)
BuildRequires: perl(Test::HTTP::Server::Simple)
BuildRequires: perl(Time::HiRes)
BuildRequires: perl(URI)
BuildRequires: perl(URI::Escape)
BuildRequires: rpm-macros-rpmforge
Requires: perl
Requires: perl(Carp)
Requires: perl(Data::Dumper)
Requires: perl(HTTP::Request)
Requires: perl(HTTP::Response)
Requires: perl(HTTP::Server::Simple::CGI)
Requires: perl(HTTP::Status)
Requires: perl(IO::Select)
Requires: perl(LWP::UserAgent)
Requires: perl(Net::HTTP)
Requires: perl(Net::HTTP::NB)
Requires: perl(Net::HTTPS::NB)
Requires: perl(Time::HiRes)
Requires: perl(URI)
Requires: perl(URI::Escape)

### remove autoreq Perl dependencies
%filter_from_requires /^perl.*/d
%filter_setup

# don't scan the examples for autoreq/prov
%filter_requires_in %{_docdir}
%filter_provides_in %{_docdir}

%description
lthough using the conventional LWP::UserAgent is fast and easy it does have
some drawbacks - the code execution blocks until the request has been completed
and it is only possible to process one request at a time. HTTP::Async attempts
to address these limitations.

It gives you a 'Async' object that you can add requests to, and then get the
requests off as they finish. The actual sending and receiving of the requests
is abstracted. As soon as you add a request it is transmitted, if there are too
many requests in progress at the moment they are queued. There is no concept of
starting or stopping - it runs continuously.

Whilst it is waiting to receive data it returns control to the code that called
it meaning that you can carry out processing whilst fetching data from the
network. All without forking or threading - it is actually done using select
lists.

%prep
%setup -n %{real_name}-%{version}

# fix problem with modules generated by older versions of Dist::Zilla
#%{?el5:%{__perl} -pi -e '/.*ExtUtils::MakeMaker.*6\.31.*/ && s/6\.3\d/6.30/' Makefile.PL}

%build
%{__perl} Makefile.PL INSTALLDIRS="vendor" PREFIX="%{perl_prefix}"
%{__make} %{?_smp_mflags}

%install
%{__rm} -rf %{buildroot}
%{__make} pure_install
#%{__rm} -rf %{buildroot}%{perl_archlib} %{buildroot}%{perl_vendorarch}

# fix for stupid strip issue
#%{__chmod} -R u+w %{buildroot}/*

%clean
%{__rm} -rf %{buildroot}

%files
%defattr(-, root, root, 0755)
%doc Changes META.json README.md TODO
%doc %{_mandir}/man?/*
%{perl_vendorlib}/HTTP/Async.pm
%{perl_vendorlib}/HTTP/Async/*
#%exclude %{perl_archlib}/perllocal.pod
%exclude %{perl_vendorarch}/auto/*/*/.packlist

%changelog
* Thu Jan 30 2014 Steve Huff <shuff@vecna.org> - 0.23-1
- Initial package.
